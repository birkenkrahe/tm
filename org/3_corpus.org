#+TITLE: Text mining in practice - Bag of Words - corpus creation
#+AUTHOR: Marcus Birkenkrahe
#+SUBTITLE: Digital Humanities DSC 105 Spring 2023 
#+STARTUP:overview hideblocks indent
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args:R :session *R* :results output :exports both :noweb yes
* README

- Creation of a text source using the ~tm~ package
- Creation of a volatile corpus from a vector
- Creation of a volatile corpus from a data frame
- Checking metadata and inspecting a corpus
- Building a data frame from scratch

* TODO Indexing list structures

      - A good way to repeat the ~list~ structure is this (very short) lesson
        of the "[[https://campus.datacamp.com/courses/free-introduction-to-r/chapter-6-lists?ex=1][Introduction to R]]" DataCamp course.

      - Lists can contain any other R object (called /elements/): matrices,
        vectors, data frames, or other lists.

      - A list element is addressed (indexed) with the ~[[ ]]~ operator, while
        values of the list element are addressed with the ~[ ]~ operator as
        usual.

      - Example: let's create a list ~LIST~ of the following elements
        1) a 2 x 2 ~matrix~ ~m~ with four ~integer~ numbers
        2) a ~character~ vector ~foo~ that contains your first names
        3) a vector ~bar~ with today's date
        4) a ~numeric~ vector ~baz~ of the number of characters of ~bar~
        #+begin_src R
          m <- matrix(data=1:4,nrow=2)
          foo <- c("Marcus", "Martin", "Bernhard", "Wolfgang", "Heinrich")
          bar <- date()
          baz <- nchar(bar)  
          LIST <- list(m,"name"=foo,"date"=bar,baz)
          LIST
        #+end_src

      - Printing the list shows four elements - two of them are named, two
        are unnamed. The structure shows this, too:
        #+begin_src R
          str(LIST)
        #+end_src

      - When extracting elements or values within elements, you can use
        names if they exist.

      - How can you extract the stored date?
        #+begin_src R
          LIST[[3]] # using the element index
          LIST[[3]][1] # pointing at the first value of the 3rd element
          LIST$date # this works because the element is named
          LIST$date[1] # pointing at the first value of the 'date' element
        #+end_src

      - How can you extract the 2nd of the first names, "Martin"?
        #+begin_src R
          LIST[[2]][2]
          LIST$name[2]
          LIST[[2]][-c(1,3,4,5)] # remove all the other names
        #+end_src

* TODO The ~tm~ text mining package

- The ~tm~ package for text mining comes with a /vignette/ ([[https://cran.r-project.org/web/packages/tm/vignettes/tm.pdf][Feinerer,
  2022]]). Its date reveals that the paper is up to date.

- Load ~tm~ and check the loaded package list with ~search()~:
  #+begin_src R
    library(tm)
    search()
  #+end_src

- There is no separate data package. Check which functions ~tm~ contains:
  #+begin_src R
    ls("package:tm")
  #+end_src

- Texts are processed at different levels:
  1) Strings like "Hello world"
  2) Documents like a text of many strings stored as vector, dataframe
  3) Corpora as collections of documents

- We'll get back to this paper when we learn to clean text data     

- Use ~VectorSource~ to create a /source/ from a /character/ vector:
  #+begin_src R
    doc <- c("This is a text.", "This is another one.")
    doc_source <- VectorSource(doc)
    doc_source
  #+end_src

- The source ~doc_source~ is a ~list~ of five elements and an attribute:
  1) ~encoding~ says that the content is encoded with apostrophs.
  2) ~length = 2~ is the length of the input vector
  3) ~position = 0~ means that there is no other document in the corpus
  4) ~reader~ is the function used to process the vector
  5) ~content~ is the content of the corpus - two strings
  6) ~attr~ is a vector that says what type of source this is
  #+begin_src R
    typeof(doc_source)
  #+end_src

- To turn the ~VectorSource~ into a volatile (in-memory) corpus, use
  ~VCorpus~ (also a ~list~): 
  #+begin_src R
    doc_corpus <- VCorpus(VectorSource(doc))
    doc_corpus
    typeof(doc_corpus)
  #+end_src

- A corpus can have metadata - this only only has two "documents",
  i.e. the two strings. A corpus can have thousands of documents.

- You can inspect the corpus with ~inspect~. This provides information
  about each of the documents - 
  #+begin_src R
    inspect(doc_corpus)
  #+end_src

- Individual documents can be accessed with the ~[[~ operator or via
  their name:
  #+begin_src R
    meta(doc_corpus[[2]]) # metadata for document no. 2 (list index)
    meta(doc_corpus[[2]],"language") # metadata for document language
  #+end_src

- Accessing the corpus document content with ~content~:
  #+begin_src R
    content(doc_corpus[[2]])
  #+end_src

* TODO Getting the ~coffee.csv~ data (again)

- Dataframes and vectors created during a session are deleted once the
  session is ended unless the session is stored (then they can be
  found in an ~.RData~ file) - so we need to re-import the data.

- The coffee tweets still sit in the ~CSV~ file. We import them into a
  data frame ~tweets~ and check that the file is okay with ~str~:
  #+begin_src R
    tweets <- read.csv(file="../data/coffee.csv")
    str(tweets)
  #+end_src

  - Be mindful that this only works if the computer can find the file:
    in my code example, I stored it in the ~data~ directory, which is at
    the same level as the directory this Org-mode file is in, ~org~:
    #+attr_latex: :width 400px
    #+caption: Directories tm and tm/data with coffee.csv
    [[../img/3_dired.png]]

- This Org-mode file ~3_corpus.org~ expects to find the R console in the
  buffer ~*R*~. If the current working directory, which you can get with
  ~getwd()~ is not ~org~, it will produce a connection error:
  #+attr_latex: :width 400px
  #+caption: Directories tm and tm/data with coffee.csv
  [[../img/3_error.png]]

- Find the current working directory for your R session with ~getwd~:
  #+begin_src R
    getwd()
  #+end_src

- This should be the same directory that this file is currently in:
  #+begin_src R
    shell("cd",intern=TRUE)
  #+end_src  
  
- You can check that without reading the output of the commands:
  #+begin_src R
    identical(getwd(), # current R working directory
              gsub("\\\\", # find \\ and replace it by 
                   "/",    # /
                   shell("cd",intern=TRUE))) # where you are
  #+end_src

* TODO Making a ~VectorSource~ from ~tweets~

- Now we have the data frame and extract the ~text~ from it. To be sure,
  we print the first three tweets.
  #+begin_src R
    coffee_tweets <- tweets$text
    head(coffee_tweets, n=3)
  #+end_src

- Now we have a vector with text. The steps to get a source are:
  1) load the ~tm~ package (re-loading does no harm)
  2) make a source from the vector using ~VectorSource~
  3) display structure of the source
  #+begin_src R
    library(tm)
    coffee_source <- VectorSource(coffee_tweets)
    str(coffee_source)   
  #+end_src

- We recognize the familiar list elements from the general explanation
  of the ~tm~ package.

- Print the first 2 tweets in ~coffee_source~
  #+begin_src R
    head(coffee_source,n=2)
  #+end_src

- Print the 999th tweet in ~coffee_source~
  #+begin_src R
    coffee_source$content[999] # with the list element and the index
    coffee_source[[999]] # list element only
    coffee_source[999]  # index only
  #+end_src
  
* TODO Making a ~VCorpus~ from a vector of tweets

- Use ~VCorpus~, to create a corpus ~coffee_corpus~ from ~coffee_source~,
  then print ~coffee_corpus~:
  #+begin_src R
    coffee_corpus <- VCorpus(coffee_source)
    coffee_corpus   
  #+end_src

- The corpus is a /container/, hence the content is not printed, only
  indicated.
   
* TODO Accessing the corpus list with index or ~content~

- Look at its structure to see how to get to the content - but not the
  structure of the whole thing since the metadata are overwhelming -
  instead only at the structure of the first list item.
  #+begin_src R
    str(coffee_corpus[[1]])
  #+end_src

- Inspect the data - select the 15th tweet from the corpus:
  #+begin_src R
   inspect(coffee_corpus[[15]])
  #+end_src

- To extract the content of the 15th tweet in this volatile corpus,
  you can either use your ~list~ indexing powers, or use ~content~:
  #+begin_src R
    coffee_corpus[[15]][1] # select list element by index and entry
    coffee_corpus[[15]]["content"] # select by index and name
    coffee_corpus[[15]]$content # select by name
    content(coffee_corpus[[15]]) # select with content function
  #+end_src   

- How many characters does the 15th tweet have? (You already know this
  value from the ~inspect~ above):
  #+begin_src R
    nchar(coffee_corpus[[15]]$content)
  #+end_src
 
* TODO Making a ~DataframeSource~ from tweets

- Often, larger amounts of data are in dataframes (i.e. tables of
  vectors) rather than individual vectors.

- To demonstrate, turn the vector ~coffee_tweets~ into a dataframe with
  the function ~data.frame~, and show its structure:
  #+begin_src R
    coffee_tweets.df <- data.frame(coffee_tweets)
    str(coffee_tweets.df)
  #+end_src

- This dataframe has one feature (~coffee_tweets.df$coffee_tweets~) and
  1000 records or lines.

- However, to turn a dataframe into a source, the dataframe must have
  a very specific structure:
  1. Column 1 must be called ~doc_id~ with a unique string for each row.
  2. Column 2 must be called ~text~ with standard ~"UTF-8"~ encoding.
  3. Columns 3+ are metadata and will be retained as such
  
- ~coffee_tweets.df~ does *not* fulfil these conditions - the first column
  is called ~coffee_tweets~. But we can reformat it:
  1) add a column 1 that is called ~doc_id~ and contains a record ID
  2) change the column name to ~text~
  #+begin_src R
    df <- data.frame(
      "doc_id" = 1:1000,
      "text" = coffee_tweets.df$coffee_tweets)
    str(df)
  #+end_src

- Now we're good to go for ~DataframeSource~:
  #+begin_src R
    df_source <- DataframeSource(df)
    str(df_source)
  #+end_src
 
- The source looks similar to the output of ~VectorSource~, of course,
  except that the content is a 1000 x 2 table, not a 1000 element
  vector.

* TODO Making a ~VCorpus~ from the dataframe source

- Let's turn this monster frame into a corpus and access some tweets:
  #+begin_src R
    df_corpus <- VCorpus(df_source)
    df_corpus
  #+end_src

- Compare this with ~coffee_corpus~ that we derived from a vector:
  #+begin_src R
    coffee_corpus # got this from VCorpus(coffee_source)
  #+end_src

* TODO Checking metadata with ~meta~

- The metadata for our examples, ~coffee_corpus~ and ~df_corpus~ are
  minimal, because we extracted the text only from the dataframe
  ~tweets~:
  #+begin_src R
    meta(coffee_corpus)
    meta(df_corpus)
  #+end_src

- Let's construct an example dataframe with some metadata to
  illustrate the use of ~meta~. This is the table we wish to construct -
  it already fulfils the conditions to build a source from a
  dataframe:
  #+attr_latex: :width 400px
  [[../img/3_example.png]]

- We use the ~data.frame~ function to build this table from scratch:
  #+begin_src R
    example <-
      data.frame( "doc_id"=c(1,2,3),
                 "text"=c("Text mining is a great time.",
                          "Text analysis provides insights",
                          "qdap and tm are used in text mining"),
                 "author"=c("Author1","Author2","Author3"),
                 "date"=c("1514953399","1514866998","1514780598"))
    example
  #+end_src

- Success! Now the usual steps to build our corpus:
  1) build source ~list~ with ~DataframeSource~
  2) build volatile corpus ~list~ with ~VCorpus~
  #+begin_src R
    example_source <- DataframeSource(example)
    example_corpus <- VCorpus(example_source)
    example_corpus
  #+end_src

- Inspect the corpus with ~inspect~:
  #+begin_src R
   inspect(example_corpus)
  #+end_src

- Finally, extraction of the metadata with ~meta~:
  #+begin_src R
    meta(example_corpus)
  #+end_src

* TODO TM Glossary - concepts and code

| TERM                | MEANING                                    |
|---------------------+--------------------------------------------|
| ~tm~                  | Text mining package                        |
| ~[[~                  | List element index                         |
| ~[~                   | Vector element index                       |
| ~List[[2]][5]~        | Extracts 5th value of 2nd element of ~List~  |
| ~x[-n]~               | Removes nth element of vector ~x~            |
| Vignette            | Documentation for an R package (paper)     |
| ~ls()~                | List all objects in current session        |
| ~ls('package:tm')~    | List all objects in package ~tm~             |
| ~tm::VectorSource~    | Build source ~list~ from vector              |
| ~tm::VCorpus~         | Build corpus ~list~ from source              |
| ~tm::DataframeSource~ | BUild source ~list~ from dataframe           |
| ~data.frame~          | Create data frame                          |
| ~typeof~              | Return R data type or data structure       |
| ~tm::inspect~         | Get information about each corpus element  |
| ~tm::meta~            | Extract metadata from corpus               |
| ~tm::content~         | Extract ~content~ element from corpus ~list~ |



