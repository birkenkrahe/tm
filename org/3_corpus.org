#+TITLE: Text mining in practice - Bag of Words - corpus creation
#+AUTHOR: Marcus Birkenkrahe
#+SUBTITLE: Digital Humanities DSC 105 Spring 2023
#+STARTUP:overview hideblocks indent inlineimages
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args:R :session *R* :results output :exports both :noweb yes
* README

After a short review of ~list~ structures, this lecture closely follows
the DataCamp lesson by Ted Kwartler (see also his 2019 book).
- Creation of a text source using the ~tm~ package
- Creation of a volatile corpus from a vector
- Creation of a volatile corpus from a data frame
- Checking metadata and inspecting a corpus
- Building a data frame from scratch

Download and open the practice file ~3_corpus_practice.org~ to code
along.

* Indexing list structures

- A good way to repeat the ~list~ structure is this (very short) lesson
  of the "[[https://campus.datacamp.com/courses/free-introduction-to-r/chapter-6-lists?ex=1][Introduction to R]]" DataCamp course.

- Lists can contain any other R object (called /elements/): matrices,
  vectors, data frames, or other lists.

- A list element is addressed (indexed) with the ~[[ ]]~ operator, while
  values of the list element are addressed with the ~[ ]~ operator as
  usual.

- Example: let's create a list ~LIST~ of the following elements
  1) a 2 x 2 ~matrix~ ~m~ with four ~integer~ numbers
  2) a ~character~ vector ~foo~ that contains your first names
  3) a vector ~bar~ with today's date
  4) a ~numeric~ vector ~baz~ of the number of characters of ~bar~
  #+begin_src R
    m <- matrix(data=1:4,nrow=2)
    foo <- c("Marcus", "Martin", "Bernhard", "Wolfgang", "Heinrich")
    bar <- date()
    baz <- nchar(bar)
    LIST <- list(m,"name"=foo,"date"=bar,baz)
    LIST
  #+end_src

- Printing the list shows four elements - two of them are named, two
  are unnamed. The structure shows this, too:
  #+begin_src R
    str(LIST)
  #+end_src

- When extracting elements or values within elements, you can use
  names if they exist.

- How can you extract the stored date?
  #+begin_src R
    LIST[[3]] # using the element index
    LIST[[3]][1] # pointing at the first value of the 3rd element
    LIST$date # this works because the element is named
    LIST$date[1] # pointing at the first value of the 'date' element
  #+end_src

- How can you extract the 2nd of the first names, "Martin"?
  #+begin_src R
    LIST[[2]][2]
    LIST$name[2]
    LIST[[2]][-c(1,3,4,5)] # remove all the other names
  #+end_src

* The ~tm~ text mining package

- The ~tm~ package for text mining comes with a /vignette/ ([[https://cran.r-project.org/web/packages/tm/vignettes/tm.pdf][Feinerer,
  2022]]). Its date reveals that the paper is up to date.

- Load ~tm~ and check the loaded package list with ~search()~:
  #+begin_src R
    library(tm)
    search()
  #+end_src

- There is no separate data package. Check which functions ~tm~ contains:
  #+begin_src R
    ls("package:tm")
  #+end_src
- Texts are processed at different levels:
  1) Strings like "Hello world"
  2) Documents like a text of many strings stored as vector, dataframe
  3) Corpora as collections of documents

- We'll get back to this paper when we learn to clean text data

- Use ~VectorSource~ to create a /source/ from a /character/ vector:
  #+begin_src R
    doc <- c("This is a text.", "This is another one.")
    doc_source <- VectorSource(doc)
    doc_source
  #+end_src

- The source ~doc_source~ is a ~list~ of five elements and an attribute:
  1) ~encoding~ says that the content is encoded with apostrophs.
  2) ~length = 2~ is the length of the input vector
  3) ~position = 0~ means that there is no other document in the corpus
  4) ~reader~ is the function used to process the vector
  5) ~content~ is the content of the corpus - two strings
  6) ~attr~ is a vector that says what type of source this is
  #+begin_src R
    typeof(doc_source)
  #+end_src

- To turn the ~VectorSource~ into a volatile (in-memory) corpus, use
  ~VCorpus~ (also a ~list~):
  #+begin_src R
    doc_corpus <- VCorpus(VectorSource(doc))
    doc_corpus
    typeof(doc_corpus)
  #+end_src

- A corpus can have metadata - this only only has two "documents",
  i.e. the two strings. A corpus can have thousands of documents.

- You can inspect the corpus with ~inspect~. This provides information
  about each of the documents -
  #+begin_src R
    inspect(doc_corpus)
  #+end_src

- Individual documents can be accessed with the ~[[~ operator or via
  their name:
  #+begin_src R
    meta(doc_corpus[[2]]) # metadata for document no. 2 (list index)
    meta(doc_corpus[[2]],"language") # metadata for document language
  #+end_src

- Accessing the corpus document content with ~content~:
  #+begin_src R
    content(doc_corpus[[2]])
  #+end_src

* TODO Getting the ~coffee.csv~ data (again)

- Dataframes and vectors created during a session are deleted once the
  session is ended unless the session is stored (then they can be
  found in an ~.RData~ file) - so we need to re-import the data.

- The coffee tweets still sit in the ~CSV~ file. We import them into a
  data frame ~tweets~ and check that the file is okay with ~str~:
  #+begin_src R
    tweets <- read.csv(file="../data/coffee.csv")
    str(tweets)
  #+end_src

  #+RESULTS:
  #+begin_example
  'data.frame':	1000 obs. of  15 variables:
   $ num         : int  1 2 3 4 5 6 7 8 9 10 ...
   $ text        : chr  "@ayyytylerb that is so true drink lots of coffee" "RT @bryzy_brib: Senior March tmw morning at 7:25 A.M. in the SENIOR lot. Get up early, make yo coffee/breakfast"| __truncated__ "If you believe in #gunsense tomorrow would be a very good day to have your coffee any place BUT @Starbucks Guns"| __truncated__ "My cute coffee mug. http://t.co/2udvMU6XIG" ...
   $ favorited   : logi  FALSE FALSE FALSE FALSE FALSE FALSE ...
   $ replyToSN   : chr  "ayyytylerb" NA NA NA ...
   $ created     : chr  "8/9/2013 2:43" "8/9/2013 2:43" "8/9/2013 2:43" "8/9/2013 2:43" ...
   $ truncated   : logi  FALSE FALSE FALSE FALSE FALSE FALSE ...
   $ replyToSID  : num  3.66e+17 NA NA NA NA ...
   $ id          : num  3.66e+17 3.66e+17 3.66e+17 3.66e+17 3.66e+17 ...
   $ replyToUID  : int  1637123977 NA NA NA NA NA NA 1316942208 NA NA ...
   $ statusSource: chr  "<a href=\"http://twitter.com/download/iphone\" rel=\"nofollow\">Twitter for iPhone</a>" "<a href=\"http://twitter.com/download/iphone\" rel=\"nofollow\">Twitter for iPhone</a>" "web" "<a href=\"http://twitter.com/download/android\" rel=\"nofollow\">Twitter for Android</a>" ...
   $ screenName  : chr  "thejennagibson" "carolynicosia" "janeCkay" "AlexandriaOOTD" ...
   $ retweetCount: int  0 1 0 0 2 0 0 0 1 2 ...
   $ retweeted   : logi  FALSE FALSE FALSE FALSE FALSE FALSE ...
   $ longitude   : logi  NA NA NA NA NA NA ...
   $ latitude    : logi  NA NA NA NA NA NA ...
  #+end_example

- Be mindful that this only works if the computer can find the file:
  in my code example, I stored it in the ~data~ directory, which is at
  the same level as the directory this Org-mode file is in, ~org~:
  #+attr_latex: :width 400px
  #+caption: Directories tm and tm/data with coffee.csv
  [[../img/3_dired.png]]

- This Org-mode file ~3_corpus.org~ expects to find the R console in the
  buffer ~*R*~. If the current working directory, which you can get with
  ~getwd()~ is not ~org~, it will produce a connection error:
  #+attr_latex: :width 400px
  #+caption: Directories tm and tm/data with coffee.csv
  [[../img/3_error.png]]

- Find the current working directory for your R session with ~getwd~:
  #+begin_src R
    getwd()
  #+end_src

- This should be the same directory that this buffer is currently in:
  #+name: default_directory
  #+begin_src emacs-lisp
    (symbol-value 'default-directory)
  #+end_src

- Reset the current working directory with ~setwd~, e.g. to ~Downloads~:
  #+begin_example R
    setwd("~/Downloads")
  #+end_example
  
* TODO Making a ~VectorSource~ from ~tweets~

- Now we have the data frame and extract the ~text~ from it. To be sure,
  we print the first three tweets.
  #+begin_src R
    coffee_tweets <- tweets$text
    head(coffee_tweets, n=3)
  #+end_src

  #+RESULTS:
  : [1] "@ayyytylerb that is so true drink lots of coffee"                                                                                            
  : [2] "RT @bryzy_brib: Senior March tmw morning at 7:25 A.M. in the SENIOR lot. Get up early, make yo coffee/breakfast, cus this will only happen ?"
  : [3] "If you believe in #gunsense tomorrow would be a very good day to have your coffee any place BUT @Starbucks Guns+Coffee=#nosense @MomsDemand"

- Now we have a vector with text. The steps to get a source are:
  1) load the ~tm~ package (re-loading does no harm)
  2) make a source from the vector using ~VectorSource~
  3) display structure of the source
  #+begin_src R
    library(tm)
    coffee_source <- VectorSource(coffee_tweets)
    str(coffee_source)
  #+end_src

  #+RESULTS:
  : Classes 'VectorSource', 'SimpleSource', 'Source'  hidden list of 5
  :  $ encoding: chr ""
  :  $ length  : int 1000
  :  $ position: num 0
  :  $ reader  :function (elem, language, id)  
  :  $ content : chr [1:1000] "@ayyytylerb that is so true drink lots of coffee" "RT @bryzy_brib: Senior March tmw morning at 7:25 A.M. in the SENIOR lot. Get up early, make yo coffee/breakfast"| __truncated__ "If you believe in #gunsense tomorrow would be a very good day to have your coffee any place BUT @Starbucks Guns"| __truncated__ "My cute coffee mug. http://t.co/2udvMU6XIG" ...

- We recognize the familiar list elements from the general explanation
  of the ~tm~ package.

- Print the first 2 tweets in ~coffee_source~
  #+begin_src R
    head(coffee_source,n=2)
  #+end_src

- Print the 999th tweet in ~coffee_source~
  #+begin_src R
    coffee_source$content[999] # with the list element and the index
    coffee_source[[999]] # list element only
    coffee_source[999]  # index only
  #+end_src

* TODO Making a ~VCorpus~ from a vector of tweets

- Use ~VCorpus~, to create a corpus ~coffee_corpus~ from ~coffee_source~,
  then print ~coffee_corpus~:
  #+begin_src R
    coffee_corpus <- VCorpus(coffee_source)
    coffee_corpus
  #+end_src

  #+RESULTS:
  : <<VCorpus>>
  : Metadata:  corpus specific: 0, document level (indexed): 0
  : Content:  documents: 1000

- The corpus is a /container/, hence the content is not printed, only
  indicated.

* TODO Accessing the corpus list with index or ~content~

- Look at its structure to see how to get to the content - but not the
  structure of the whole thing since the metadata are overwhelming -
  instead only at the structure of the first list item.
  #+begin_src R
    str(coffee_corpus[[1]])
  #+end_src

- Inspect the data - select the 15th tweet from the corpus:
  #+begin_src R
    inspect(coffee_corpus[[15]])
  #+end_src

  #+RESULTS:
  : <<PlainTextDocument>>
  : Metadata:  7
  : Content:  chars: 111
  : 
  : @HeatherWhaley I was about 2 joke it takes 2 hands to hold hot coffee...then I read headline! #Don'tDrinkNShoot

- To extract the content of the 15th tweet in this volatile corpus,
  you can either use your ~list~ indexing powers, or use ~content~:
  #+begin_src R
    coffee_corpus[[15]][1] # select list element by index and entry
    coffee_corpus[[15]]["content"] # select by index and name
    coffee_corpus[[15]]$content # select by name
    content(coffee_corpus[[15]]) # select with content function
  #+end_src

- How many characters does the 15th tweet have? (You already know this
  value from the ~inspect~ above):
  #+begin_src R
    nchar(coffee_corpus[[15]]$content)
  #+end_src

#+begin_src R
meta(coffee_corpus)
#+end_src  

#+RESULTS:
: data frame with 0 columns and 1000 rows

* TODO Making a ~DataframeSource~ from tweets

- Often, larger amounts of data are in dataframes (i.e. tables of
  vectors) rather than individual vectors.

- To demonstrate, turn the vector ~coffee_tweets~ into a dataframe with
  the function ~data.frame~, and show its structure:
  #+begin_src R
    coffee_tweets.df <- data.frame(coffee_tweets)
    str(coffee_tweets.df)
  #+end_src

- This dataframe has one feature (~coffee_tweets.df$coffee_tweets~) and
  1000 records or lines.

- However, to turn a dataframe into a source, the dataframe must have
  a very specific structure:
  1. Column 1 must be called ~doc_id~ with a unique string for each row.
  2. Column 2 must be called ~text~ with standard ~"UTF-8"~ encoding.
  3. Columns 3+ are metadata and will be retained as such

- ~coffee_tweets.df~ does *not* fulfil these conditions - the first column
  is called ~coffee_tweets~. But we can reformat it:
  1) add a column 1 that is called ~doc_id~ and contains a record ID
  2) change the column name to ~text~
  #+begin_src R
    df <- data.frame(
      "doc_id" = 1:1000,
      "text" = coffee_tweets.df$coffee_tweets)
    str(df)
  #+end_src

- Now we're good to go for ~DataframeSource~:
  #+begin_src R
    df_source <- DataframeSource(df)
    str(df_source)
  #+end_src

- The source looks similar to the output of ~VectorSource~, of course,
  except that the content is a 1000 x 2 table, not a 1000 element
  vector.

* TODO Making a ~VCorpus~ from the dataframe source

- Let's turn this monster frame into a corpus and access some tweets:
  #+begin_src R
    df_corpus <- VCorpus(df_source)
    df_corpus
  #+end_src

- Compare this with ~coffee_corpus~ that we derived from a vector:
  #+begin_src R
    coffee_corpus # got this from VCorpus(coffee_source)
  #+end_src

* TODO Checking metadata with ~meta~

- The metadata for our examples, ~coffee_corpus~ and ~df_corpus~ are
  minimal, because we extracted the text only from the dataframe
  ~tweets~:
  #+begin_src R
    meta(coffee_corpus)
    meta(df_corpus)
  #+end_src

- Let's construct an example dataframe with some metadata to
  illustrate the use of ~meta~. This is the table we wish to construct -
  it already fulfils the conditions to build a source from a
  dataframe:
  #+attr_latex: :width 400px
  [[../img/3_example.png]]

- We use the ~data.frame~ function to build this table from scratch:
  #+begin_src R
    example <-
      data.frame( "doc_id"=c(1,2,3),
                 "text"=c("Text mining is a great time.",
                          "Text analysis provides insights",
                          "qdap and tm are used in text mining"),
                 "author"=c("Author1","Author2","Author3"),
                 "date"=c("1514953399","1514866998","1514780598"))
    example
  #+end_src

- Success! Now the usual steps to build our corpus:
  1) build source ~list~ with ~DataframeSource~
  2) build volatile corpus ~list~ with ~VCorpus~
  #+begin_src R
    example_source <- DataframeSource(example)
    example_corpus <- VCorpus(example_source)
    example_corpus
  #+end_src

  #+RESULTS:
  : Error in DataframeSource(example) : 
  :   could not find function "DataframeSource"
  : Error in VCorpus(example_source) : could not find function "VCorpus"
  : Error: object 'example_corpus' not found

- Inspect the corpus with ~inspect~:
  #+begin_src R
    inspect(example_corpus)
  #+end_src

- Finally, extraction of the metadata with ~meta~:
  #+begin_src R
    meta(example_corpus)
  #+end_src

* TODO TM Glossary - concepts and code

| TERM                | MEANING                                   |
|---------------------+-------------------------------------------|
| ~tm~                  | Text mining package                       |
| ~[[~                  | List element index                        |
| ~[~                   | Vector element index                      |
| ~List[[2]][5]~        | Extracts 5th value of 2nd element of ~List~ |
| ~x[-n]~               | Removes nth element of vector ~x~           |
| Vignette            | Documentation for an R package (paper)    |
| ~ls()~                | List all objects in current session       |
| ~ls('package:tm')~    | List all objects in package ~tm~            |
| ~tm::VectorSource~    | Build source ~list~ from vector             |
| ~tm::VCorpus~         | Build corpus ~list~ from source             |
| ~tm::DataframeSource~ | BUild source ~list~ from dataframe          |
| ~data.frame~          | Create data frame                         |
| ~typeof~              | Return R data type or data structure      |
| ~tm::inspect~         | Get information about each corpus element |
| ~tm::meta~            | Extract metadata from corpus              |
| ~tm::content~         | Extract ~content~ element from corpus ~list~  |

