#+TITLE: PRACTICE FILE - Bag of Words - corpus creation and tm package
#+AUTHOR: Marcus Birkenkrahe
#+SUBTITLE: Digital Humanities DSC 105 Spring 2023 
#+STARTUP:overview hideblocks indent
#+OPTIONS: toc:nil num:nil ^:nil
#+PROPERTY: header-args:R :session *R* :results output :exports both :noweb yes
* README

This file covers corpus creation for the Bag-of-Word method

- Creation of a text source using the ~tm~ package
- Creation of a volatile corpus from a vector
- Creation of a volatile corpus from a data frame
- Checking metadata and inspecting a corpus
- Building a data frame from scratch

Some of this material can be found in Kwartler, Text mining in
practice with R (Wiley, 2019), and in Kwartler's DataCamp course on
Text mining with Bag-of-Words.

* TODO Identify and pledge yourself

1) In Emacs, replace the placeholder ~[yourname]~ at the top of this
   file by your own name and write ~(pledged)~ next to it
2) Go with the cursor on the headline and hange the ~TODO~ label to ~DONE~
   by entering ~S-<right>~ ("Shift + right-arrow").

* TODO Indexing list structures

- Example: let's create a list ~LIST~ of the following elements
  1) a 2 x 2 ~matrix~ ~m~ with four ~integer~ numbers
  2) a ~character~ vector ~foo~ that contains your names
  3) a vector ~bar~ with today's date
  4) a ~numeric~ vector ~baz~ of the number of characters of ~bar~
  #+begin_src R
 
  #+end_src

- Print the list structure:
  #+begin_src R
 
  #+end_src

- How can you extract the stored date?
  #+begin_src R
 
  #+end_src

- How can you extract the 2nd of the names list element?
  #+begin_src R
 
  #+end_src
 
* TODO The ~tm~ text mining package

- Vignette for the ~tm~ package for text mining: [[https://cran.r-project.org/web/packages/tm/vignettes/tm.pdf][Feinerer, 2022]]. 

- Load ~tm~ and check the loaded package list with ~search()~:
  #+begin_src R
 
  #+end_src

- Check which functions ~tm~ contains:
  #+begin_src R
 
  #+end_src

- Use ~VectorSource~ to create a /source/ from a /character/ vector:
  #+begin_src R
 
  #+end_src

- Run ~typeof~ on ~doc_source~ to see the data structure:
  #+begin_src R
 
  #+end_src

- To turn the ~VectorSource~ into a volatile (in-memory) corpus, use
  ~VCorpus~ (also a ~list~): 
  #+begin_src R
 
  #+end_src

- You can inspect the corpus with ~inspect~ 
  #+begin_src R
 
  #+end_src

- Individual documents can be accessed with the ~[[~ operator or by name
  #+begin_src R
 
  #+end_src

- Accessing the corpus document content with ~content~:
  #+begin_src R
 
  #+end_src

* TODO Getting the ~coffee.csv~ data (again)

- The coffee tweets still sit in the ~CSV~ file. We import them into a
  data frame ~tweets~ and check that the file is okay with ~str~:
  #+begin_src R
 
  #+end_src

- Find the current working directory for your R session with ~getwd~:
  #+begin_src R
 
  #+end_src

- This should be the same directory that this file is currently in:
  #+begin_src R
 
  #+end_src  

* TODO Making a ~VectorSource~ from ~tweets~

- Extract the ~text~ vector from ~tweets~ and put it into
  ~coffee_tweets~. Then print the first three tweets of ~coffee_tweets~.
  #+begin_src R
 
  #+end_src

- Now we have a vector with text. The steps to get a source are:
  1) load the ~tm~ package (re-loading does no harm)
  2) make a source from the vector using ~VectorSource~
  3) display structure of the source
  #+begin_src R
 
  #+end_src

- Print the first 2 tweets in ~coffee_source~
  #+begin_src R
 
  #+end_src

- Print the 999th tweet in ~coffee_source~
  #+begin_src R
 
  #+end_src

* TODO Making a ~VCorpus~ from a vector of tweets

- Use ~VCorpus~, to create a corpus ~coffee_corpus~ from ~coffee_source~,
  then print ~coffee_corpus~:
  #+begin_src R
 
  #+end_src
    
* TODO Accessing the corpus list with index or ~content~

- Look at the structure of the first list item.
  #+begin_src R
 
  #+end_src

- Inspect the data - select the 15th tweet from the corpus:
  #+begin_src R
 
  #+end_src

- To extract the content of the 15th tweet in this volatile corpus,
  you can either use your ~list~ indexing powers, or use ~content~:
  #+begin_src R
 
  #+end_src   

- How many characters does the 15th tweet have? (You already know this
  value from the ~inspect~ above):
  #+begin_src R
 
  #+end_src
 
* TODO Making a ~DataframeSource~ from tweets

- Turn the vector ~coffee_tweets~ into a dataframe with the function
  ~data.frame~, and show its structure:
  #+begin_src R
 
  #+end_src
 
- ~coffee_tweets.df~ does *not* fulfil the conditions for
  ~DataframeSource~ - the first column is called ~coffee_tweets~. Reformat:
  1) add a column 1 that is called ~doc_id~ and contains a record ID
  2) change the column name to ~text~
  #+begin_src R
 
  #+end_src

- Now we're good to go for ~DataframeSource~:
   #+begin_src R
 
  #+end_src

* TODO Making a ~VCorpus~ from the dataframe source

- Let's turn this monster frame into a corpus and access some tweets:
  #+begin_src R
 
  #+end_src

- Compare this with ~coffee_corpus~ that we derived from a vector:
  #+begin_src R
 
  #+end_src

* TODO Checking metadata with ~meta~

- Show the metadata for ~coffee_corpus~ and ~df_corpus~:
  #+begin_src R
 
  #+end_src
  
- [[https://github.com/birkenkrahe/tm/blob/main/img/3_example.png][This is the table we wish to construct.]] It already fulfils the
  conditions to build a source from a dataframe.
  
- Use the ~data.frame~ function to build this table from scratch:
  #+begin_src R
 
  #+end_src

- Success! Now the usual steps to build our corpus:
  1) build source ~list~ with ~DataframeSource~
  2) build volatile corpus ~list~ with ~VCorpus~
  #+begin_src R
 
  #+end_src

- Inspect the corpus with ~inspect~:
  #+begin_src R
 
  #+end_src

- Finally, extraction of the metadata with ~meta~:
  #+begin_src R
 
  #+end_src
